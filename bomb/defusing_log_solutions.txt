This is my thoughts on defusing the bomb lab.

Phase 1:
  I first tried to disassemble the code in initialize_bomb() and see what was fishy there. But I stuck at some mystery <signal@plt> function call, and after some hours inspecting the code and reading the csapp book, I decided to not bother about this function and dived into the phase_1() function.
  Yeah, I was heading the right way of inspecting the phase_1() function. I found there is a function call to <strings_equal>, which takes the 0x****(don't remember) as the string pointer and is compared to the user input string. All I have to do is to get the sequential value starting from 0x**** until I hit the null(0x00) and decode them via an ASCII table. Yeah, the solution for phase 1 is "Border relations with Cananda have never been better.". Done!


Phase 2:
  With the knowedge of defusing the first phase, this one is quit easy to begin with. Although the road is a bit winding, every dark corner is enlightened after I understand the function<read_six_numbers>(it shouldn't have stuck me for that long, since the critical part is to understand the famoud <sscanf> c function which I get acquantant with couple of years ago). Then what's been left is just some common arithmic logic wouldn't be difficult to follow.


Phase 3:
  Under defusing previous phases, this one comes rather straight fowward. Following the arithmic logic would give us the solution easily. But there is some codes seem "redundant", maybe they are for generating mulitple solutions for this problem??

--edit--
The code is not redundant. These different code segments are invoked based on the firt argument we feed the bomb. There is a line like "jmp *0x...(, $rax, 8)"that jumps to a specific line and execute its following code determined by our firt argument which is stored in $rsp + 8.


Phase 4
  This phase does't have any tricky operations. All we need to do is to follow the operation logic and figure out what they are doing as a whole. 
